// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{ADDRESS_VERIFICATION_REGISTRY_GUEST_ELF, ADDRESS_VERIFICATION_REGISTRY_GUEST_ID};
use risc0_zkvm::{default_prover, ExecutorEnv, ProverOpts};

use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
struct GuestOutputs {
    p2pkh_address: String,
    arbitrary_bytes: Vec<u8>,
    pq_addresses: Vec<String>,
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let arbitrary_bytes: Vec<u8> = vec![1, 2, 3, 4, 5];
    let pq_addresses: Vec<String> = vec![
        "1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa".to_string(),
        "3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy".to_string(),
    ];

    let bitcoin_version_byte: u8 = 0x00;

    let sig_bytes= hex::decode("eb29513e8081bf404879b0540ddeb935bf018ba116b00afa27b4a82036d090fa7d4d713a29f412c07574e05e4794435d123f704f194181a8f6bfae60b7c453eb").unwrap();
    let pk_bytes = hex::decode("bed944b767b458553411f6c613f752476a6fbdd2c0837d48b7c187eb38e8e938dddf421ece6b5d6d7009d238e7eb4e42c5ffb6c5192e8864473d48eebbef9a6c").unwrap();

    // let sig_bytes = sig.to_bytes().to_vec();

    let sig_r = hex::encode(&sig_bytes[0..32]);
    let sig_s = hex::encode(&sig_bytes[32..64]);

    println!("Signature: r = {}, s = {}", sig_r, sig_s);

    let pk_x = hex::encode(&pk_bytes[0..32]);
    let pk_y = hex::encode(&pk_bytes[32..64]);

    println!("Public Key: x = {}, y = {}", pk_x, pk_y);

    let env = ExecutorEnv::builder()
        .write(&pk_bytes)
        .unwrap()
        .write(&arbitrary_bytes)
        .unwrap()
        .write(&pq_addresses)
        .unwrap()
        .write(&bitcoin_version_byte)
        .unwrap()
        .write(&sig_bytes)
        .unwrap()
        .build()
        .unwrap();

    let proof_start_time = std::time::Instant::now();

    let opts = ProverOpts::groth16();

    let prove_info = default_prover()
        .prove_with_opts(env, ADDRESS_VERIFICATION_REGISTRY_GUEST_ELF, &opts)
        .unwrap();

    let proof_duration = proof_start_time.elapsed();
    println!("Proof generated in: {:?}", proof_duration);

    let receipt = prove_info.receipt;

    let outputs: GuestOutputs = receipt.journal.decode().unwrap();

    println!("P2PKH Address: {}", outputs.p2pkh_address);
    // println!("Arbitrary Bytes: {:?}", outputs.arbitrary_bytes);
    // println!("PQ Addresses: {:?}", outputs.pq_addresses);

    let verification_start_time = std::time::Instant::now();

    receipt
        .verify(ADDRESS_VERIFICATION_REGISTRY_GUEST_ID)
        .unwrap();

    let verification_duration = verification_start_time.elapsed();
    println!("Verification completed in: {:?}", verification_duration);
}

#[cfg(test)]
mod tests {
    use k256::{
        ecdsa::{RecoveryId, Signature, VerifyingKey},
        sha2::{Digest, Sha256},
    };

    #[test]
    fn test_retrive_recovery_id() {
        let sig_bytes: &[u8]= &hex::decode("eb29513e8081bf404879b0540ddeb935bf018ba116b00afa27b4a82036d090fa7d4d713a29f412c07574e05e4794435d123f704f194181a8f6bfae60b7c453eb").unwrap();
        let pk_bytes: &[u8] = &hex::decode("bed944b767b458553411f6c613f752476a6fbdd2c0837d48b7c187eb38e8e938dddf421ece6b5d6d7009d238e7eb4e42c5ffb6c5192e8864473d48eebbef9a6c").unwrap();

        let msg_hash =
            hex::decode("9887376a3882fda1a251bb1a1bfcfa404dc76301df9cc124d4b108ca2573dcec")
                .unwrap();

        let mut uncompressed_pk = vec![0x04];
        uncompressed_pk.extend_from_slice(pk_bytes);

        let encoded_point_pk = k256::EncodedPoint::from_bytes(&uncompressed_pk)
            .expect("Failed to create encoded point from public key bytes");

        // Parse public key
        let verifying_key = VerifyingKey::from_encoded_point(&encoded_point_pk).unwrap();

        // Parse signature
        let signature = Signature::from_bytes(sig_bytes.into()).unwrap();

        let post_hash = Sha256::new_with_prefix(&msg_hash).finalize();

        println!("Post Hash: {}", hex::encode(post_hash));

        let recovered_verifying_key =
            VerifyingKey::recover_from_msg(&msg_hash, &signature, RecoveryId::new(true, false))
                .unwrap();

        println!("RecoveryID: {}", RecoveryId::new(true, false).to_byte());

        assert_eq!(verifying_key, recovered_verifying_key);
    }
}
